### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AccessControl {
  id: String!
  role: SourceRole!
  source: Source!
  user: User!
}

input AccessControl_user_sourceCompoundUniqueInput {
  sourceId: String!
  userId: String!
}

input AccessControlListRelationFilter {
  every: AccessControlWhereInput
  none: AccessControlWhereInput
  some: AccessControlWhereInput
}

input AccessControlWhereInput {
  AND: [AccessControlWhereInput!]
  id: StringFilter
  NOT: [AccessControlWhereInput!]
  OR: [AccessControlWhereInput!]
  role: EnumSourceRoleFilter
  source: SourceWhereInput
  sourceId: StringFilter
  user: UserWhereInput
  userId: StringFilter
}

input AccessControlWhereUniqueInput {
  AccessControl_user_source: AccessControl_user_sourceCompoundUniqueInput
  id: String
}

type Attribute {
  comments(after: CommentWhereUniqueInput, before: CommentWhereUniqueInput, first: Int, last: Int): [Comment!]!
  createdAt: DateTime!

  """Structured version of a definition"""
  definition: StructureDefinition
  definitionId: String!
  id: String!
  inputGroups(after: InputGroupWhereUniqueInput, before: InputGroupWhereUniqueInput, first: Int, last: Int): [InputGroup!]!
  path: String!
  resource: Resource
  sliceName: String
  updatedAt: DateTime!
}

type AttributeDefinition {
  attribute: JSON

  """List of extensions on this type"""
  extensions: [StructureDefinition]
  id: String
}

input AttributeInput {
  mergingScript: String
}

input AttributeListRelationFilter {
  every: AttributeWhereInput
  none: AttributeWhereInput
  some: AttributeWhereInput
}

input AttributeWhereInput {
  AND: [AttributeWhereInput!]
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  definitionId: StringFilter
  id: StringFilter
  inputGroups: InputGroupListRelationFilter
  NOT: [AttributeWhereInput!]
  OR: [AttributeWhereInput!]
  path: StringFilter
  resource: ResourceWhereInput
  resourceId: StringNullableFilter
  sliceName: StringNullableFilter
  updatedAt: DateTimeFilter
}

input AttributeWhereUniqueInput {
  id: String
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Column {
  column: String
  createdAt: DateTime!
  id: String!
  joins(after: JoinWhereUniqueInput, before: JoinWhereUniqueInput, first: Int, last: Int): [Join!]!
  table: String
  updatedAt: DateTime!
}

input ColumnInput {
  column: String!
  joins: [JoinInput]
  table: String!
}

input ColumnInputWithoutJoins {
  column: String
  table: String
}

input ColumnListRelationFilter {
  every: ColumnWhereInput
  none: ColumnWhereInput
  some: ColumnWhereInput
}

input ColumnWhereInput {
  AND: [ColumnWhereInput!]
  column: StringNullableFilter
  condition: ConditionWhereInput
  createdAt: DateTimeFilter
  filter: FilterWhereInput
  id: StringFilter
  input: InputWhereInput
  join: JoinWhereInput
  joinId: StringNullableFilter
  joins: JoinListRelationFilter
  NOT: [ColumnWhereInput!]
  OR: [ColumnWhereInput!]
  table: StringNullableFilter
  updatedAt: DateTimeFilter
}

input ColumnWhereUniqueInput {
  id: String
}

type Comment {
  attribute: Attribute
  author: User!
  content: String!
  createdAt: DateTime!
  id: String!
  validation: Boolean!
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  attribute: AttributeWhereInput
  attributeId: StringNullableFilter
  author: UserWhereInput
  authorId: StringFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  updatedAt: DateTimeFilter
  validation: BoolFilter
}

input CommentWhereUniqueInput {
  id: String
}

type ConceptMap {
  id: String
  name: String
  title: String
}

type Condition {
  action: ConditionAction
  id: String!
  relation: ConditionRelation!
  sqlValue: Column
  value: String
}

enum ConditionAction {
  EXCLUDE
  INCLUDE
}

input ConditionListRelationFilter {
  every: ConditionWhereInput
  none: ConditionWhereInput
  some: ConditionWhereInput
}

enum ConditionRelation {
  EQ
  GE
  GT
  LE
  LT
  NOTNULL
  NULL
}

input ConditionWhereInput {
  action: EnumConditionActionNullableFilter
  AND: [ConditionWhereInput!]
  columnId: StringNullableFilter
  id: StringFilter
  inputGroup: InputGroupWhereInput
  inputGroupId: StringFilter
  NOT: [ConditionWhereInput!]
  OR: [ConditionWhereInput!]
  relation: EnumConditionRelationFilter
  sqlValue: ColumnWhereInput
  value: StringNullableFilter
}

input ConditionWhereUniqueInput {
  id: String
}

type Credential {
  createdAt: DateTime!
  database: String!
  decryptedPassword: String
  host: String!
  id: String!
  login: String!
  model: DatabaseType!
  owner: String!
  password: String!
  port: String!
  schema: String
  source: Source!
  updatedAt: DateTime!
}

input CredentialWhereInput {
  AND: [CredentialWhereInput!]
  createdAt: DateTimeFilter
  database: StringFilter
  host: StringFilter
  id: StringFilter
  login: StringFilter
  model: EnumDatabaseTypeFilter
  NOT: [CredentialWhereInput!]
  OR: [CredentialWhereInput!]
  owner: StringFilter
  password: StringFilter
  port: StringFilter
  schema: StringNullableFilter
  source: SourceWhereInput
  sourceId: StringFilter
  updatedAt: DateTimeFilter
}

input CredentialWhereUniqueInput {
  id: String
}

enum DatabaseType {
  MSSQL
  ORACLE
  POSTGRES
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input EnumConditionActionNullableFilter {
  equals: ConditionAction
  in: [ConditionAction!]
  not: NestedEnumConditionActionNullableFilter
  notIn: [ConditionAction!]
}

input EnumConditionRelationFilter {
  equals: ConditionRelation
  in: [ConditionRelation!]
  not: NestedEnumConditionRelationFilter
  notIn: [ConditionRelation!]
}

input EnumDatabaseTypeFilter {
  equals: DatabaseType
  in: [DatabaseType!]
  not: NestedEnumDatabaseTypeFilter
  notIn: [DatabaseType!]
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumSourceRoleFilter {
  equals: SourceRole
  in: [SourceRole!]
  not: NestedEnumSourceRoleFilter
  notIn: [SourceRole!]
}

type Filter {
  id: String!
  relation: String!
  sqlColumn: Column!
  value: String!
}

input FilterInput {
  relation: String!
  sqlColumn: ColumnInputWithoutJoins!
  value: String!
}

input FilterListRelationFilter {
  every: FilterWhereInput
  none: FilterWhereInput
  some: FilterWhereInput
}

input FilterWhereInput {
  AND: [FilterWhereInput!]
  id: StringFilter
  NOT: [FilterWhereInput!]
  OR: [FilterWhereInput!]
  relation: StringFilter
  resource: ResourceWhereInput
  resourceId: StringNullableFilter
  sqlColumn: ColumnWhereInput
  sqlColumnId: StringFilter
  value: StringFilter
}

type Input {
  conceptMapId: String
  createdAt: DateTime!
  id: String!
  inputGroup: InputGroup
  script: String
  sqlValue: Column
  staticValue: String
  updatedAt: DateTime!
}

type InputGroup {
  attribute: Attribute
  conditions(after: ConditionWhereUniqueInput, before: ConditionWhereUniqueInput, first: Int, last: Int): [Condition!]!
  createdAt: DateTime!
  id: String!
  inputs(after: InputWhereUniqueInput, before: InputWhereUniqueInput, first: Int, last: Int): [Input!]!
  mergingScript: String
  updatedAt: DateTime!
}

input InputGroupListRelationFilter {
  every: InputGroupWhereInput
  none: InputGroupWhereInput
  some: InputGroupWhereInput
}

input InputGroupWhereInput {
  AND: [InputGroupWhereInput!]
  attribute: AttributeWhereInput
  attributeId: StringNullableFilter
  conditions: ConditionListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  inputs: InputListRelationFilter
  mergingScript: StringNullableFilter
  NOT: [InputGroupWhereInput!]
  OR: [InputGroupWhereInput!]
  updatedAt: DateTimeFilter
}

input InputGroupWhereUniqueInput {
  id: String
}

input InputListRelationFilter {
  every: InputWhereInput
  none: InputWhereInput
  some: InputWhereInput
}

input InputWhereInput {
  AND: [InputWhereInput!]
  conceptMapId: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  inputGroup: InputGroupWhereInput
  inputGroupId: StringNullableFilter
  NOT: [InputWhereInput!]
  OR: [InputWhereInput!]
  script: StringNullableFilter
  sqlValue: ColumnWhereInput
  sqlValueId: StringNullableFilter
  staticValue: StringNullableFilter
  updatedAt: DateTimeFilter
}

input InputWhereUniqueInput {
  id: String
}

type Join {
  createdAt: DateTime!
  id: String!
  tables(after: ColumnWhereUniqueInput, before: ColumnWhereUniqueInput, first: Int, last: Int): [Column!]!
  updatedAt: DateTime!
}

input JoinInput {
  source: ColumnInputWithoutJoins
  target: ColumnInputWithoutJoins
}

input JoinListRelationFilter {
  every: JoinWhereInput
  none: JoinWhereInput
  some: JoinWhereInput
}

input JoinWhereInput {
  AND: [JoinWhereInput!]
  column: ColumnWhereInput
  columnId: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [JoinWhereInput!]
  OR: [JoinWhereInput!]
  tables: ColumnListRelationFilter
  updatedAt: DateTimeFilter
}

input JoinWhereUniqueInput {
  id: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Mutation {
  addConditionToInputGroup(action: String, column: String, inputGroupId: ID!, relation: ConditionRelation, table: String, value: String): InputGroup
  addJoinToColumn(columnId: ID!, join: JoinInput): Column
  createAccessControl(role: SourceRole!, sourceId: ID!, userEmail: String!): AccessControl
  createAttribute(data: AttributeInput, definitionId: ID!, path: String!, resourceId: ID!, sliceName: String): Attribute
  createComment(attributeId: ID!, content: String!, validation: Boolean!): Comment
  createInput(inputGroupId: ID!, script: String, sql: ColumnInput, static: String): Input
  createInputGroup(attributeId: ID!): InputGroup
  createResource(definitionId: String!, sourceId: ID!): Resource
  createSource(mapping: String, name: String!, templateName: String!): Source
  createTemplate(name: String!): Template
  deleteAccessControl(accessControlId: ID!): AccessControl
  deleteAttribute(attributeId: ID!): Attribute
  deleteAttributes(filter: AttributeWhereInput): Attribute
  deleteCondition(conditionId: ID!): Condition
  deleteCredential(credentialId: ID!): Credential
  deleteInput(inputId: ID!): Input
  deleteJoin(joinId: ID!): Join
  deleteResource(resourceId: ID!): Resource
  deleteSource(sourceId: ID!): Source
  deleteTemplate(id: ID!): Template
  logout: User
  updateCondition(action: String, column: String, conditionId: ID!, relation: ConditionRelation, table: String, value: String): Condition
  updateInput(data: UpdateInputInput!, inputId: ID!): Input
  updateInputGroup(inputGroupId: ID!, mergingScript: String): InputGroup
  updateJoin(data: JoinInput!, joinId: ID!): Join
  updateResource(data: UpdateResourceInput!, filters: [FilterInput], resourceId: ID!): Resource
  updateRole(newRole: Role!, userId: ID!): User
  upsertCredential(database: String!, host: String!, login: String!, model: String!, owner: String!, password: String!, port: String!, sourceId: ID!): Credential
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedEnumConditionActionNullableFilter {
  equals: ConditionAction
  in: [ConditionAction!]
  not: NestedEnumConditionActionNullableFilter
  notIn: [ConditionAction!]
}

input NestedEnumConditionRelationFilter {
  equals: ConditionRelation
  in: [ConditionRelation!]
  not: NestedEnumConditionRelationFilter
  notIn: [ConditionRelation!]
}

input NestedEnumDatabaseTypeFilter {
  equals: DatabaseType
  in: [DatabaseType!]
  not: NestedEnumDatabaseTypeFilter
  notIn: [DatabaseType!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumSourceRoleFilter {
  equals: SourceRole
  in: [SourceRole!]
  not: NestedEnumSourceRoleFilter
  notIn: [SourceRole!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  attribute(where: AttributeWhereUniqueInput!): Attribute
  attributes(after: AttributeWhereUniqueInput, before: AttributeWhereUniqueInput, first: Int, last: Int, where: AttributeWhereInput): [Attribute!]!
  credential(where: CredentialWhereUniqueInput!): Credential
  me: User
  resource(where: ResourceWhereUniqueInput!): Resource
  source(where: SourceWhereUniqueInput!): Source
  sources: [Source]
  structureDefinition(definitionId: ID!): StructureDefinition
  template(where: TemplateWhereUniqueInput!): Template
  templates(after: TemplateWhereUniqueInput, before: TemplateWhereUniqueInput, first: Int, last: Int): [Template!]!
}

enum QueryMode {
  default
  insensitive
}

type Resource {
  attributes(after: AttributeWhereUniqueInput, before: AttributeWhereUniqueInput, first: Int, last: Int): [Attribute!]!
  createdAt: DateTime!

  """Structured version of a definition"""
  definition: StructureDefinition
  definitionId: String!
  filters: [Filter!]!
  id: String!
  label: String
  logicalReference: String!
  primaryKeyColumn: String
  primaryKeyTable: String
  source: Source!
  updatedAt: DateTime!
}

input ResourceListRelationFilter {
  every: ResourceWhereInput
  none: ResourceWhereInput
  some: ResourceWhereInput
}

input ResourceWhereInput {
  AND: [ResourceWhereInput!]
  attributes: AttributeListRelationFilter
  createdAt: DateTimeFilter
  definitionId: StringFilter
  filters: FilterListRelationFilter
  id: StringFilter
  label: StringNullableFilter
  logicalReference: StringFilter
  NOT: [ResourceWhereInput!]
  OR: [ResourceWhereInput!]
  primaryKeyColumn: StringNullableFilter
  primaryKeyTable: StringNullableFilter
  source: SourceWhereInput
  sourceId: StringFilter
  updatedAt: DateTimeFilter
}

input ResourceWhereUniqueInput {
  id: String
}

enum Role {
  ADMIN
  USER
}

type Source {
  accessControls(after: AccessControlWhereUniqueInput, before: AccessControlWhereUniqueInput, first: Int, last: Int): [AccessControl!]!
  createdAt: DateTime!
  credential: Credential
  id: String!
  mapping(includeComments: Boolean! = true): String
  mappingProgress: [Int]
  name: String!
  resources(after: ResourceWhereUniqueInput, before: ResourceWhereUniqueInput, first: Int, last: Int): [Resource!]!
  template: Template!
  updatedAt: DateTime!
  usedConceptMapIds: [String]
  usedProfileIds: [String]
  version: String
}

input Source_templateId_nameCompoundUniqueInput {
  name: String!
  templateId: String!
}

input SourceListRelationFilter {
  every: SourceWhereInput
  none: SourceWhereInput
  some: SourceWhereInput
}

enum SourceRole {
  READER
  WRITER
}

input SourceWhereInput {
  accessControls: AccessControlListRelationFilter
  AND: [SourceWhereInput!]
  createdAt: DateTimeFilter
  credential: CredentialWhereInput
  id: StringFilter
  name: StringFilter
  NOT: [SourceWhereInput!]
  OR: [SourceWhereInput!]
  resources: ResourceListRelationFilter
  template: TemplateWhereInput
  templateId: StringFilter
  updatedAt: DateTimeFilter
  version: StringNullableFilter
}

input SourceWhereUniqueInput {
  id: String
  Source_templateId_name: Source_templateId_nameCompoundUniqueInput
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type StructureDefinition {
  """Structured version of the attributes"""
  attributes: [AttributeDefinition]
  derivation: String
  id: String
  kind: String
  name: String
  publisher: String
  type: String
  url: String
}

input StructureDefinitionWhereFilter {
  derivation: String
  kind: String
  type: String
}

type Template {
  createdAt: DateTime!
  id: String!
  name: String!
  sources(after: SourceWhereUniqueInput, before: SourceWhereUniqueInput, first: Int, last: Int): [Source!]!
  updatedAt: DateTime!
}

input TemplateWhereInput {
  AND: [TemplateWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TemplateWhereInput!]
  OR: [TemplateWhereInput!]
  sources: SourceListRelationFilter
  updatedAt: DateTimeFilter
}

input TemplateWhereUniqueInput {
  id: String
  name: String
}

input UpdateInputInput {
  conceptMapId: String
  script: String
}

input UpdateResourceInput {
  label: String
  primaryKeyColumn: String
  primaryKeyTable: String
}

type User {
  createdAt: DateTime!
  email: String!
  id: String!
  name: String!
  role: Role!
  updatedAt: DateTime!
}

input UserWhereInput {
  AccessControl: AccessControlListRelationFilter
  AND: [UserWhereInput!]
  Comment: CommentListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}
