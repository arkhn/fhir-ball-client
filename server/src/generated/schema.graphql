### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type AccessControl {
  id: ID!
  role: SourceRole!
  source: Source!
  user: User!
}

input AccessControlFilter {
  every: AccessControlWhereInput
  none: AccessControlWhereInput
  some: AccessControlWhereInput
}

input AccessControlWhereInput {
  AND: [AccessControlWhereInput!]
  id: StringFilter
  NOT: [AccessControlWhereInput!]
  OR: [AccessControlWhereInput!]
  role: SourceRole
  source: SourceWhereInput
  user: UserWhereInput
}

type Attribute {
  comments: String
  createdAt: DateTime!

  """Structured version of a definition"""
  definition: StructureDefinition!
  definitionId: String!
  id: ID!
  inputs(after: ID, before: ID, first: Int, last: Int, skip: Int): [Input!]!
  mergingScript: String
  path: String!
  resource: Resource
  updatedAt: DateTime!
}

input AttributeFilter {
  every: AttributeWhereInput
  none: AttributeWhereInput
  some: AttributeWhereInput
}

input AttributeInput {
  comments: String
  mergingScript: String
}

input AttributeWhereInput {
  AND: [AttributeWhereInput!]
  comments: NullableStringFilter
  createdAt: DateTimeFilter
  definitionId: StringFilter
  id: StringFilter
  inputs: InputFilter
  mergingScript: NullableStringFilter
  NOT: [AttributeWhereInput!]
  OR: [AttributeWhereInput!]
  path: StringFilter
  resource: ResourceWhereInput
  updatedAt: DateTimeFilter
}

type AuthPayload {
  token: String!
  user: User!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type Column {
  column: String
  createdAt: DateTime!
  id: ID!
  joins(after: ID, before: ID, first: Int, last: Int, skip: Int): [Join!]!
  owner: String
  table: String
  updatedAt: DateTime!
}

input ColumnFilter {
  every: ColumnWhereInput
  none: ColumnWhereInput
  some: ColumnWhereInput
}

input ColumnInput {
  column: String!
  joins: [JoinInput!]
  owner: String!
  table: String!
}

input ColumnInputWithoutJoins {
  column: String
  owner: String
  table: String
}

input ColumnWhereInput {
  AND: [ColumnWhereInput!]
  column: NullableStringFilter
  createdAt: DateTimeFilter
  filter: FilterWhereInput
  id: StringFilter
  input: InputWhereInput
  join: JoinWhereInput
  joins: JoinFilter
  NOT: [ColumnWhereInput!]
  OR: [ColumnWhereInput!]
  owner: NullableStringFilter
  table: NullableStringFilter
  updatedAt: DateTimeFilter
}

type ConceptMap {
  id: String!
  name: String!
  title: String!
}

type Credential {
  createdAt: DateTime!
  database: String!
  host: String!
  id: ID!
  login: String!
  model: DatabaseType!
  password: String!
  port: String!
  source: Source!
  updatedAt: DateTime!
}

input CredentialWhereInput {
  AND: [CredentialWhereInput!]
  createdAt: DateTimeFilter
  database: StringFilter
  host: StringFilter
  id: StringFilter
  login: StringFilter
  model: DatabaseType
  NOT: [CredentialWhereInput!]
  OR: [CredentialWhereInput!]
  password: StringFilter
  port: StringFilter
  source: SourceWhereInput
  updatedAt: DateTimeFilter
}

enum DatabaseType {
  ORACLE
  POSTGRES
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

type Filter {
  id: ID!
  relation: String!
  sqlColumn: Column!
  value: String!
}

input FilterFilter {
  every: FilterWhereInput
  none: FilterWhereInput
  some: FilterWhereInput
}

input FilterInput {
  relation: String!
  sqlColumn: ColumnInputWithoutJoins!
  value: String!
}

input FilterWhereInput {
  AND: [FilterWhereInput!]
  id: StringFilter
  NOT: [FilterWhereInput!]
  OR: [FilterWhereInput!]
  relation: StringFilter
  resource: ResourceWhereInput
  sqlColumn: ColumnWhereInput
  value: StringFilter
}

type Input {
  attribute: Attribute!
  conceptMap: ConceptMap
  conceptMapId: String
  createdAt: DateTime!
  id: ID!
  script: String
  sqlValue: Column
  staticValue: String
  updatedAt: DateTime!
}

input InputFilter {
  every: InputWhereInput
  none: InputWhereInput
  some: InputWhereInput
}

input InputWhereInput {
  AND: [InputWhereInput!]
  attribute: AttributeWhereInput
  conceptMapId: NullableStringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [InputWhereInput!]
  OR: [InputWhereInput!]
  script: NullableStringFilter
  sqlValue: ColumnWhereInput
  staticValue: NullableStringFilter
  updatedAt: DateTimeFilter
}

type Join {
  createdAt: DateTime!
  id: ID!
  tables(after: ID, before: ID, first: Int, last: Int, skip: Int): [Column!]!
  updatedAt: DateTime!
}

input JoinFilter {
  every: JoinWhereInput
  none: JoinWhereInput
  some: JoinWhereInput
}

input JoinInput {
  source: ColumnInputWithoutJoins
  target: ColumnInputWithoutJoins
}

input JoinWhereInput {
  AND: [JoinWhereInput!]
  column: ColumnWhereInput
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [JoinWhereInput!]
  OR: [JoinWhereInput!]
  tables: ColumnFilter
  updatedAt: DateTimeFilter
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Mutation {
  addJoinToColumn(columnId: ID!, join: JoinInput): Column!
  createAccessControl(role: SourceRole!, sourceId: ID!, userId: ID!): AccessControl!
  createAttribute(data: AttributeInput, definitionId: ID!, path: String!, resourceId: ID!): Attribute!
  createInput(attributeId: ID!, script: String, sql: ColumnInput, static: String): Input!
  createResource(definitionId: String!, sourceId: ID!): Resource!
  createSource(hasOwner: Boolean!, mapping: String, name: String!, templateName: String!): Source!
  createTemplate(name: String!): Template!
  deleteAttribute(attributeId: ID!): Attribute!
  deleteAttributes(filter: AttributeWhereInput): [Attribute!]
  deleteCredential(credentialId: ID!): Credential!
  deleteFilter(filterId: ID!): Filter!
  deleteInput(inputId: ID!): Input!
  deleteJoin(joinId: ID!): Join!
  deleteResource(resourceId: ID!): Resource!
  deleteSource(sourceId: ID!): Source!
  deleteTemplate(id: ID!): Template!
  login(email: String!, password: String!): AuthPayload!
  refreshDefinition(definitionId: ID!): StructureDefinition!
  signup(email: String!, name: String!, password: String!): AuthPayload!
  updateAttribute(attributeId: ID!, data: AttributeInput!): Attribute!
  updateComments(attributeId: ID!, comments: String!): Attribute!
  updateInput(data: UpdateInputInput!, inputId: ID!): Input!
  updateJoin(data: JoinInput!, joinId: ID!): Join!
  updateResource(data: UpdateResourceInput!, filters: [FilterInput!], resourceId: ID!): Resource!
  upsertCredential(database: String!, host: String!, login: String!, model: String!, password: String!, port: String!, sourceId: ID!): Credential!
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  allSources: [Source!]
  attribute(attributeId: ID!): Attribute
  credential(credentialId: ID!): Credential
  me: User
  resource(resourceId: ID!): Resource
  resourcesForUser(filter: ResourceWhereInput, userId: ID!): [Resource!]
  source(sourceId: ID!): Source
  sources: [Source!]
  structureDefinition(definitionId: ID!): StructureDefinition
  structureDefinitions(filter: StructureDefinitionWhereFilter!): [StructureDefinition!]
  template(templateId: ID!): Template
  templates: [Template!]
}

type Resource {
  attributes(after: ID, before: ID, first: Int, last: Int, skip: Int): [Attribute!]!
  createdAt: DateTime!

  """Structured version of a definition"""
  definition: StructureDefinition!
  definitionId: String!
  filters: [Filter!]!
  id: ID!
  label: String
  primaryKeyColumn: String
  primaryKeyOwner: String
  primaryKeyTable: String
  source: Source!
  updatedAt: DateTime!
}

input ResourceFilter {
  every: ResourceWhereInput
  none: ResourceWhereInput
  some: ResourceWhereInput
}

input ResourceWhereInput {
  AND: [ResourceWhereInput!]
  attributes: AttributeFilter
  createdAt: DateTimeFilter
  definitionId: StringFilter
  filters: FilterFilter
  id: StringFilter
  label: NullableStringFilter
  NOT: [ResourceWhereInput!]
  OR: [ResourceWhereInput!]
  primaryKeyColumn: NullableStringFilter
  primaryKeyOwner: NullableStringFilter
  primaryKeyTable: NullableStringFilter
  source: SourceWhereInput
  updatedAt: DateTimeFilter
}

enum Role {
  ADMIN
  USER
}

type Source {
  createdAt: DateTime!
  credential: Credential
  hasOwner: Boolean!
  id: ID!
  mapping: String!
  mappingProgress: [Int!]
  name: String!
  resources(after: ID, before: ID, first: Int, last: Int, skip: Int, where: ResourceWhereInput): [Resource!]!
  template: Template!
  updatedAt: DateTime!
  version: String
}

input SourceFilter {
  every: SourceWhereInput
  none: SourceWhereInput
  some: SourceWhereInput
}

enum SourceRole {
  READER
  WRITER
}

input SourceWhereInput {
  accessControls: AccessControlFilter
  AND: [SourceWhereInput!]
  createdAt: DateTimeFilter
  credential: CredentialWhereInput
  hasOwner: BooleanFilter
  id: StringFilter
  name: StringFilter
  NOT: [SourceWhereInput!]
  OR: [SourceWhereInput!]
  resources: ResourceFilter
  template: TemplateWhereInput
  updatedAt: DateTimeFilter
  version: NullableStringFilter
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type StructureDefinition {
  derivation: String!

  """Structured version of a definition"""
  display: JSON!
  id: String!
  kind: String!
  name: String!

  """List of profiles on this resource"""
  profiles: [StructureDefinition!]!
  publisher: String!
  type: String!
  url: String!
}

input StructureDefinitionWhereFilter {
  derivation: String
  kind: String
  type: String
}

type Template {
  createdAt: DateTime!
  id: ID!
  name: String!
  sources(after: ID, before: ID, first: Int, last: Int, skip: Int): [Source!]!
  updatedAt: DateTime!
}

input TemplateWhereInput {
  AND: [TemplateWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  NOT: [TemplateWhereInput!]
  OR: [TemplateWhereInput!]
  sources: SourceFilter
  updatedAt: DateTimeFilter
}

input UpdateInputInput {
  conceptMapId: String
  script: String
}

input UpdateResourceInput {
  label: String
  primaryKeyColumn: String
  primaryKeyOwner: String
  primaryKeyTable: String
}

type User {
  createdAt: DateTime!
  email: String!
  id: ID!
  name: String!
  role: Role!
  updatedAt: DateTime!
}

input UserWhereInput {
  accessControls: AccessControlFilter
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  role: Role
  updatedAt: DateTimeFilter
}
